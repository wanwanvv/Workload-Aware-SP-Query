#pragma once
#include <vector>
#include <limits.h>
using namespace std;

//A node is in a tree decomposition and it is a one-to-one match to a vertex.
class node
{
public:
	node() {};
	//Connect nodes in indirected graph by set the node generated by the neighbor which is removed earliest.
	void setParent(vector<node>& nodes, const vector<int>& level, const vector<int>& neighbor) {
		if (neighbor.size() == 0) {
			return;
		}
		//Find the first removed neighbor.
		int parentNum{ neighbor[0] };
		for (int i = 1; i < neighbor.size(); i++) {
			if (level[neighbor[i]] < level[parentNum]) {
				parentNum = neighbor[i];
			}
		}
		parent = &nodes[parentNum];//Set parent.
		parent->child.push_back(this);//Set current node as the child of its parent.
	}

	//Connect nodes in directed graph by set the node generated by the neighbor which is removed earliest.
	void setParent_directed(vector<node>& nodes, const vector<int>& level, const vector<int>& neighbor) {
		if (neighbor_in.size() == 0 && neighbor_out.size() == 0) {//root node
			return;
		}
		//Find the first removed neighbor.
		int parentNum{ neighbor_in[0] };
		for (int i = 1; i < neighbor_in.size(); i++) {
			if (level[neighbor_in[i]] < level[parentNum]) {
				parentNum = neighbor_in[i];
			}
		}
		for (int i = 1; i < neighbor_out.size(); i++) {
			if (level[neighbor_out[i]] < level[parentNum]) {
				parentNum = neighbor_out[i];
			}
		}
		parent = &nodes[parentNum];//Set parent.
		parent->child.push_back(this);//Set current node as the child of its parent.
	}

	//Reorder neighbor and neighborDis by the sequence of removing vertex in tree decomposition.
	void reOrder(vector<int>& level) {
		if (neighborDis.size() < 2)
			return;
		int neighborDisTemp{ neighborDis[0] };
		int neighborTemp{ neighbor[0] };
		for (int i = 1; i < neighborDis.size(); i++) {
			int j = 0;
			while (level[neighbor[i]] < level[neighbor[j]] && j < i) {
				j++;
			}
			if (j < i) {
				int curLocation = j;
				neighborTemp = neighbor[i];
				neighborDisTemp = neighborDis[i];
				for (j = i; j > curLocation; j--) {
					neighbor[j] = neighbor[j - 1];
					neighborDis[j] = neighborDis[j - 1];
				}
				neighbor[curLocation] = neighborTemp;
				neighborDis[curLocation] = neighborDisTemp;
			}
		}
	}

	//Reorder neighbor and neighborDis by the sequence of removing vertex in tree decomposition.
	void reOrder_directed(vector<int>& level) {
		if (neighborDis_in.size() >= 2) {
			int neighborDisTemp{ neighborDis_in[0] };
			int neighborTemp{ neighbor_in[0] };
			for (int i = 1; i < neighborDis_in.size(); i++) {
				int j = 0;
				while (level[neighbor_in[i]] < level[neighbor_in[j]] && j < i) {
					j++;
				}
				if (j < i) {
					int curLocation = j;
					neighborTemp = neighbor_in[i];
					neighborDisTemp = neighborDis_in[i];
					for (j = i; j > curLocation; j--) {
						neighbor_in[j] = neighbor_in[j - 1];
						neighborDis_in[j] = neighborDis_in[j - 1];
					}
					neighbor_in[curLocation] = neighborTemp;
					neighborDis_in[curLocation] = neighborDisTemp;
				}
			}
		}
		if (neighborDis_out.size() >= 2) {
			int neighborDisTemp{ neighborDis_out[0] };
			int neighborTemp{ neighbor_out[0] };
			for (int i = 1; i < neighborDis_out.size(); i++) {
				int j = 0;
				while (level[neighbor_out[i]] < level[neighbor_out[j]] && j < i) {
					j++;
				}
				if (j < i) {
					int curLocation = j;
					neighborTemp = neighbor_out[i];
					neighborDisTemp = neighborDis_out[i];
					for (j = i; j > curLocation; j--) {
						neighbor_out[j] = neighbor_out[j - 1];
						neighborDis_out[j] = neighborDis_out[j - 1];
					}
					neighbor_out[curLocation] = neighborTemp;
					neighborDis_out[curLocation] = neighborDisTemp;
				}
			}
		}
	}

	//Calculate Dis and Pos in indirected graph.
	void calDis(vector<node>& nodes) {
		vector<node*> neighborAns;
		neighborAns.reserve(neighbor.size());
		pos.reserve(neighbor.size() + 1);
		dis.resize(height);
		for (int i = 0; i < neighbor.size(); i++) {
			neighborAns.push_back(&(nodes[neighbor[i]]));
			pos.push_back(nodes[neighbor[i]].height - 1);
		}
		pos.push_back(height - 1);//The last element in pos is the height of current node.
		//Calculate distance from all the neighbors in a top-down manner.
		for (int i = 0; i < allAns.size(); i++) {
			dis[i] = INT_MAX;
			for (int j = 0; j < neighborAns.size(); j++) {
				int distance{ 0 };
				if (neighborAns[j]->height > i + 1) {
					distance = neighborAns[j]->dis[i];
				}
				else {
					node* calNode = allAns[i];
					distance = calNode->dis[neighborAns[j]->height - 1];
				}
				dis[i] = dis[i] < neighborDis[j] + distance ? dis[i] : neighborDis[j] + distance;
			}
		}
		dis[allAns.size()] = 0;//The distance to the current node itself is 0.
	}

	//Calculate Dis and Pos in directed graph.
	void calDis_directed(vector<node>& nodes, const vector<vector<int>>& dis_dijkstra) {
		vector<node*> neighborAns_in;
		vector<node*> neighborAns_out;
		neighborAns_in.reserve(neighbor_in.size());
		neighborAns_out.reserve(neighbor_out.size());
		//pos_in.reserve(neighbor_in.size() + 1);
		pos.reserve(neighbor_in.size() + neighbor_out.size() + 1);
		
		//Record neighborAns_in, neighborAns_out, and the position of neighbors.
		for (int i = 0, j = 0; i < neighbor_in.size() && j < neighbor_out.size(); ) {
			int height_in = nodes[neighbor_in[i]].height - 1;
			int height_out = nodes[neighbor_out[j]].height - 1;
			if (height_in == height_out) {
				pos.push_back(height_in);
				neighborAns_in.push_back(&(nodes[neighbor_in[i]]));
				neighborAns_out.push_back(&(nodes[neighbor_out[j]]));
				i++;
				j++;
			}
			else if (height_in < height_out) {
				pos.push_back(height_in);
				neighborAns_in.push_back(&(nodes[neighbor_in[i]]));
				i++;
			}
			else {
				pos.push_back(height_out);
				neighborAns_out.push_back(&(nodes[neighbor_out[j]]));
				j++;
			}
		}
		for (int i = neighborAns_in.size(); i < neighbor_in.size(); i++) {
			neighborAns_in.push_back(&(nodes[neighbor_in[i]]));
			pos.push_back(nodes[neighbor_in[i]].height - 1);
		}
		for (int i = neighborAns_out.size(); i < neighbor_out.size(); i++) {
			neighborAns_out.push_back(&(nodes[neighbor_out[i]]));
			pos.push_back(nodes[neighbor_out[i]].height - 1);
		}
		pos.push_back(height - 1);//The last element in pos is the height of current node.
	
		//Calculate distance from all the neighbors in a top-down manner.
		dis_in.resize(height);
		for (int i = 0; i < allAns.size(); i++) {
			dis_in[i] = INT_MAX;
			for (int j = 0; j < neighborAns_in.size(); j++) {
				int distance{ 0 };
				if (neighborAns_in[j]->height > i + 1) {
					distance = neighborAns_in[j]->dis_in[i];
				}
				else {//Note that it must be dis_out in directed graph.
					node* calNode = allAns[i];
					distance = calNode->dis_out[neighborAns_in[j]->height - 1];
				}
				dis_in[i] = dis_in[i] < neighborDis_in[j] + distance ? dis_in[i] : neighborDis_in[j] + distance;
			}
			/*if (dis_in[i] != dis_dijkstra[allAns[i]->curNum][curNum]) {
				dis_in[i] = dis_in[i];
			}*/
		}
		dis_in[allAns.size()] = 0;//The distance to the current node itself is 0.

		//Calculate distance to all the neighbors in a top-down manner.
		dis_out.resize(height);
		for (int i = 0; i < allAns.size(); i++) {
			dis_out[i] = INT_MAX;
			for (int j = 0; j < neighborAns_out.size(); j++) {
				int distance{ 0 };
				if (neighborAns_out[j]->height > i + 1) {
					distance = neighborAns_out[j]->dis_out[i];
				}
				else {//Note that it must be dis_in in directed graph.
					node* calNode = allAns[i];
					distance = calNode->dis_in[neighborAns_out[j]->height - 1];
				}
				dis_out[i] = dis_out[i] < neighborDis_out[j] + distance ? dis_out[i] : neighborDis_out[j] + distance;
			}
			/*if (dis_out[i] != dis_dijkstra[curNum][allAns[i]->curNum]) {
				dis_out[i] = dis_out[i];
			}*/
		}
		dis_out[allAns.size()] = 0;//The distance to the current node itself is 0.
	}

	//Calculate Ans.
	void calAllANS() {
		allAns.reserve(height - 1);
		allAns = parent->allAns;
		allAns.push_back(parent);
	}

	vector<int> pos;//Record the position of neighbors in tree decomposition of an indirected graph.
	vector<int> dis;//Record real distances to all ancestors in tree decomposition of an indirected graph.
	//vector<int> pos_in;//Record the position of neighbors in tree decomposition of an directed graph.
	vector<int> dis_in;//Record real distances to all ancestors in tree decomposition of an directed graph.
	//vector<int> pos_out;//Record the position of neighbors in tree decomposition of an directed graph.
	vector<int> dis_out;//Record real distances to all ancestors in tree decomposition of an directed graph.
	vector<int> neighbor;//Record neighbors (ID) in undirected graph.
	vector<int> neighborDis;//Record edge weight to neighbors during removing the vertex in undirected graph.
	vector<int> neighbor_in;//Record neighbors (ID) of in-edge in directed graph.
	vector<int> neighbor_out;//Record neighbors (ID)  of out-edge in directed graph.
	vector<int> neighborDis_in;//Record edge weight from neighbors to current vertex during removing the vertex in directed graph.
	vector<int> neighborDis_out;//Record edge weight from current vertex to neighbors during removing the vertex in directed graph.
	vector<node*> child;//children
	vector<node*> allAns;//Record all the ancestors.
	node* parent{ NULL };
	int numOfChildren{ 0 };
	float queryCost;
	int height{ 0 };//Record height in tree decomposition. (root height is 1)
	int level{ -1 };//Record the sequence during removing vertices.
	int curNum;//vertex ID
};